## 生成公钥和私钥

基于TDD的方式实现生成秘钥的方法。
实现 examples/c01_get_key.js 中的案例需要的底层封装。我们需要一个生成公钥和私钥的方法。
我需要执行 node .\examples\c01_get_key.js 以后能够直接成功。不要修改我的代码。你可以把yggjs_gm打包成node_modules里面的包。要支持下面的这种导入方式：import gggm from 'yggjs_gm';

## sm2加密和解密

基于TDD的方式实现sm2加密和解密的方法。
实现 examples/c02_sm2_encrypt_decrypt.js 中的案例需要的底层封装。我们需要一个sm2对字符串进行加密和解密的方法。
我需要执行 node .\examples\c02_sm2_encrypt_decrypt.js 以后能够直接成功。

## js使用sm2加密，python使用sm2进行解密

## 代码混淆

基于TDD的方式实现代码混淆的功能。将npm打包的内容使用代码混淆，让使用者无法看到底层算法的具体实现，防止别人知道算法的具体细节，提高代码的安全性。

## 增加底层依赖

基于TDD的方式整合sm-crypto，将examples/c01_get_key.js的底层代码替换为如下代码：

```js
// JavaScript密钥生成
const sm2 = require('sm-crypto').sm2;

// 生成新密钥对
const keypair = sm2.generateKeyPairHex();
const publicKey = keypair.publicKey; // 04开头公钥
const privateKey = keypair.privateKey; // 64字符私钥
```

基于TDD的方式整合sm-crypto，将examples/c02_sm2_encrypt_decrypt.js的底层代码替换为如下代码：

```js
// JavaScript密钥生成
const sm2 = require('sm-crypto').sm2;

// 生成新密钥对
const keypair = sm2.generateKeyPairHex();
const publicKey = keypair.publicKey; // 04开头公钥
const privateKey = keypair.privateKey; // 64字符私钥

console.log('公钥:', publicKey);
console.log('私钥:', privateKey);

// 加密测试
const text = '测试文本';
const cipher = sm2.doEncrypt(text, publicKey, 0);
console.log('加密结果:', cipher);
```


你不能修改 examples/c02_sm2_encrypt_decrypt.js 的内容，我需要你在底层实现代码，来支持这个示例的正确运行。要支持能够和Python进行相互加密解密。
