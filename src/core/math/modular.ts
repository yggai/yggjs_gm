/**
 * 模运算
 *
 * @description 提供模运算相关的数学函数
 */

/**
 * 模加法
 *
 * @param a 被加数
 * @param b 加数
 * @param m 模数
 * @returns (a + b) mod m
 */
export function modAdd(a: bigint, b: bigint, m: bigint): bigint {
  // TODO: 实现模加法
  throw new Error('模加法功能待实现');
}

/**
 * 模减法
 *
 * @param a 被减数
 * @param b 减数
 * @param m 模数
 * @returns (a - b) mod m
 */
export function modSub(a: bigint, b: bigint, m: bigint): bigint {
  // TODO: 实现模减法
  throw new Error('模减法功能待实现');
}

/**
 * 模乘法
 *
 * @param a 被乘数
 * @param b 乘数
 * @param m 模数
 * @returns (a * b) mod m
 */
export function modMul(a: bigint, b: bigint, m: bigint): bigint {
  // TODO: 实现模乘法
  throw new Error('模乘法功能待实现');
}

/**
 * 模幂运算
 *
 * @param base 底数
 * @param exponent 指数
 * @param modulus 模数
 * @returns base^exponent mod modulus
 */
export function modPow(base: bigint, exponent: bigint, modulus: bigint): bigint {
  // TODO: 实现模幂运算
  throw new Error('模幂运算功能待实现');
}

/**
 * 模逆运算
 *
 * @param a 数值
 * @param m 模数
 * @returns a^(-1) mod m
 */
export function modInverse(a: bigint, m: bigint): bigint {
  // TODO: 实现模逆运算
  throw new Error('模逆运算功能待实现');
}

/**
 * 扩展欧几里得算法
 *
 * @param a 第一个数
 * @param b 第二个数
 * @returns [gcd, x, y] 使得 ax + by = gcd(a, b)
 */
export function extendedGcd(a: bigint, b: bigint): [bigint, bigint, bigint] {
  // TODO: 实现扩展欧几里得算法
  throw new Error('扩展欧几里得算法功能待实现');
}
